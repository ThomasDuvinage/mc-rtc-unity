/** This file was generated from @PROJECT_SOURCE_DIR@/src/types.in.h
 *
 * Do not edit this file
 */

@PREPROCESSOR@

namespace McRtc
{

@PUBLIC_ATTRIBUTE@ struct Vec3
{
  @PUBLIC_ATTRIBUTE@ float x;
  @PUBLIC_ATTRIBUTE@ float y;
  @PUBLIC_ATTRIBUTE@ float z;
#if MC_RTC_CSHARP
  public Vector3 ToVector3()
  {
    return new Vector3(x, y, z);
  }
#endif
}@END_STRUCT@

#if MC_RTC_CPP
template<typename T>
Vec3 convert(const Eigen::Vector3<T> & v)
{
  Vec3 vec;
  vec.x = static_cast<float>(v.x());
  vec.y = static_cast<float>(v.y());
  vec.z = static_cast<float>(v.z());
  return vec;
}
#endif

@PUBLIC_ATTRIBUTE@ struct Quat
{
  @PUBLIC_ATTRIBUTE@ float x;
  @PUBLIC_ATTRIBUTE@ float y;
  @PUBLIC_ATTRIBUTE@ float z;
  @PUBLIC_ATTRIBUTE@ float w;
#if MC_RTC_CSHARP
  public Quaternion ToQuaternion()
  {
    return new Quaternion(x, y, z, w);
  }
#endif
}@END_STRUCT@

#if MC_RTC_CPP
template<typename T>
Quat convert(const Eigen::Quaternion<T> & q)
{
  Quat qOut;
  qOut.x = static_cast<float>(q.x());
  qOut.y = static_cast<float>(q.y());
  qOut.z = static_cast<float>(q.z());
  qOut.w = static_cast<float>(q.w());
  return qOut;
}
#endif

@PUBLIC_ATTRIBUTE@ struct PTransform
{
  @PUBLIC_ATTRIBUTE@ Vec3 translation;
  @PUBLIC_ATTRIBUTE@ Quat rotation;
#if MC_RTC_CSHARP
  public void SetLocalTransform(GameObject obj)
  {
    obj.transform.localPosition = translation.ToVector3();
    obj.transform.localRotation = rotation.ToQuaternion();
  }
#endif
}@END_STRUCT@

#if MC_RTC_CPP
template<typename T>
PTransform convert(const sva::PTransform<T> & pt)
{
  PTransform ptOut;
  ptOut.translation = convert(pt.translation());
  ptOut.rotation = convert(Eigen::Quaterniond(pt.rotation()));
  return ptOut;
}

PTransform ToUnity(const sva::PTransformd & pt)
{
  static auto to_unity = []() -> Eigen::Matrix4f {
    Eigen::Matrix4f out = Eigen::Matrix4f::Zero();
    out(0, 0) = 1.0f;
    out(1, 2) = 1.0f;
    out(2, 1) = 1.0f;
    out(3, 3) = 1.0f;
    return out;
  }();
  auto homo =
      to_unity * sva::conversions::toHomogeneous(pt.cast<float>(), sva::conversions::RightHanded) * to_unity;
  Eigen::Quaternionf q(homo.block<3, 3>(0, 0));
  Eigen::Vector3f t = homo.block<3, 1>(0, 3);
  PTransform ptOut;
  ptOut.translation = convert(t);
  ptOut.rotation = convert(q);
  return ptOut;
}
#endif

} // namespace McRtc
